# Features

go-vibe ships with a carefully chosen set of production-grade features. This page explains each one in detail.

## User Model

The `User` model is the core domain object. It uses GORM tags for schema definition, `json:"-"` to prevent leaking password hashes, and a sensible default role of `"user"`.

```go
// internal/models/user.go
type User struct {
    gorm.Model
    ID           uint      `gorm:"primaryKey" json:"id"`
    Name         string    `gorm:"type:varchar(100);not null" json:"name"`
    Email        string    `gorm:"type:varchar(100);uniqueIndex;not null" json:"email"`
    PasswordHash string    `gorm:"type:varchar(255);not null" json:"-"`
    Role         string    `gorm:"type:varchar(20);not null;default:'user'" json:"role"`
    CreatedAt    time.Time `json:"created_at"`
    UpdatedAt    time.Time `json:"updated_at"`
}
```

Key decisions:
- `PasswordHash` has `json:"-"` — it is **never** serialised to JSON responses
- `Email` has a `uniqueIndex` — enforced at the database level
- `Role` defaults to `"user"` — only explicitly set admins get elevated privileges
- `gorm.Model` embeds `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt` (soft delete)

## JWT Authentication

Authentication uses HMAC-SHA256 signed JWTs. The secret is loaded from `JWT_SECRET` at startup — it is never hardcoded.

### Token Structure

```json
{
  "user_id": 42,
  "role": "admin",
  "exp": 1719878400,
  "iat": 1719792000
}
```

Tokens expire after **24 hours** by default.

### Auth Middleware

```go
// internal/middleware/auth.go
func AuthMiddleware(secret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "missing or invalid Authorization header"})
            return
        }

        tokenStr := strings.TrimPrefix(authHeader, "Bearer ")
        claims, err := ValidateToken(tokenStr, secret)
        if err != nil {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid or expired token"})
            return
        }

        // Inject claims into context for downstream handlers
        c.Set("user_id", claims.UserID)
        c.Set("role", claims.Role)
        c.Next()
    }
}
```

### RBAC (Role-Based Access Control)

Two roles are supported: `user` and `admin`.

| Endpoint | `user` role | `admin` role |
|----------|-------------|--------------|
| `GET /v1/users` | ❌ | ✅ |
| `GET /v1/users/:id` (own) | ✅ | ✅ |
| `GET /v1/users/:id` (other) | ❌ | ✅ |
| `PUT /v1/users/:id` (own) | ✅ | ✅ |
| `DELETE /v1/users/:id` | ❌ | ✅ |

## Repository Pattern

The data layer is abstracted behind an interface, making it trivial to swap implementations (e.g., swap PostgreSQL for SQLite in tests).

```go
// internal/repository/user_repository.go
type UserRepository interface {
    Create(ctx context.Context, user *models.User) error
    FindByID(ctx context.Context, id uint) (*models.User, error)
    FindByEmail(ctx context.Context, email string) (*models.User, error)
    FindAll(ctx context.Context) ([]models.User, error)
    Update(ctx context.Context, user *models.User) error
    Delete(ctx context.Context, id uint) error
}
```

The PostgreSQL implementation uses GORM:

```go
// internal/repository/postgres_user_repository.go
type PostgresUserRepository struct {
    db *gorm.DB
}

func (r *PostgresUserRepository) FindByID(ctx context.Context, id uint) (*models.User, error) {
    var user models.User
    if err := r.db.WithContext(ctx).First(&user, id).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, ErrUserNotFound
        }
        return nil, err
    }
    return &user, nil
}
```

Tests use a **mock** generated by `gomock`, so no database is needed at test time:

```go
mockRepo.EXPECT().
    FindByID(gomock.Any(), uint(1)).
    Return(&models.User{ID: 1, Name: "Alice"}, nil)
```

## Prometheus Metrics

go-vibe exposes a `/metrics` endpoint compatible with any Prometheus scraper.

### Tracked Metrics

| Metric | Type | Labels | Description |
|--------|------|--------|-------------|
| `http_requests_total` | Counter | `method`, `path`, `status` | Total HTTP requests |
| `http_request_duration_seconds` | Histogram | `method`, `path` | Request latency distribution |
| `users_total` | Gauge | — | Current number of registered users |

### Metrics Middleware

```go
// internal/middleware/metrics.go
func MetricsMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        c.Next()

        duration := time.Since(start).Seconds()
        status  := strconv.Itoa(c.Writer.Status())

        httpRequestsTotal.WithLabelValues(
            c.Request.Method,
            c.FullPath(),
            status,
        ).Inc()

        httpRequestDuration.WithLabelValues(
            c.Request.Method,
            c.FullPath(),
        ).Observe(duration)
    }
}
```

## Rate Limiting

A token-bucket rate limiter protects the API from abuse. Each client IP gets its own bucket.

```go
// internal/middleware/rate_limit.go
func RateLimitMiddleware(rps float64, burst int) gin.HandlerFunc {
    clients := make(map[string]*rate.Limiter)
    mu      := &sync.Mutex{}

    return func(c *gin.Context) {
        ip := c.ClientIP()

        mu.Lock()
        if _, exists := clients[ip]; !exists {
            clients[ip] = rate.NewLimiter(rate.Limit(rps), burst)
        }
        limiter := clients[ip]
        mu.Unlock()

        if !limiter.Allow() {
            c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
                "error": "rate limit exceeded",
            })
            return
        }
        c.Next()
    }
}
```

Default limits: **10 requests/second** with a burst of **20**.

## CORS

Cross-Origin Resource Sharing is handled by middleware with configurable allowed origins:

```go
// internal/middleware/cors.go
func CORSMiddleware(allowedOrigins []string) gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.Request.Header.Get("Origin")
        for _, allowed := range allowedOrigins {
            if allowed == "*" || allowed == origin {
                c.Header("Access-Control-Allow-Origin", origin)
                break
            }
        }
        c.Header("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS")
        c.Header("Access-Control-Allow-Headers", "Authorization,Content-Type")
        c.Header("Access-Control-Max-Age", "86400")

        if c.Request.Method == http.MethodOptions {
            c.AbortWithStatus(http.StatusNoContent)
            return
        }
        c.Next()
    }
}
```

Set `ALLOWED_ORIGINS=*` for development or a comma-separated list of origins for production.

## Password Security

Passwords are hashed using **bcrypt** with cost factor 12 before storage. Plain-text passwords are never persisted or logged.

```go
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), 12)
    return string(bytes), err
}

func CheckPassword(password, hash string) bool {
    return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
}
```
