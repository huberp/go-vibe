name: Scripts Smoke Test

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'scripts/**'
      - '.github/workflows/scripts-test.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'scripts/**'
      - '.github/workflows/scripts-test.yml'
  workflow_dispatch:

jobs:
  test-bash-scripts:
    name: Test Bash Scripts
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25'

    - name: Download dependencies
      run: go mod download

    - name: Test build script
      run: |
        ./scripts/build.sh
        test -f server
        ./server --version || echo "Server binary created successfully"

    - name: Test test script
      run: ./scripts/test.sh

    - name: Test run-background and stop scripts
      run: |
        # Set environment variables for the server
        export DATABASE_URL="host=localhost user=testuser password=testpassword dbname=testdb port=5432 sslmode=disable"
        export JWT_SECRET="test-secret-key"
        export SERVER_PORT="8081"
        
        # Start server in background
        ./scripts/run-background.sh || {
          echo "‚ùå Server failed to start. Dumping server.log:"
          cat server.log 2>/dev/null || echo "No server.log found"
          exit 1
        }
        
        # Wait for server to start
        sleep 3
        
        # Dump server log for debugging
        echo "üìã Server log contents:"
        cat server.log 2>/dev/null || echo "No server.log found"
        
        # Check if server is responding
        curl -f http://localhost:8081/health || echo "Health check failed, but server may be running"
        
        # Stop server
        ./scripts/stop.sh
        
        # Verify server stopped
        sleep 2
        if curl -f http://localhost:8081/health 2>/dev/null; then
          echo "Server still running!"
          exit 1
        else
          echo "Server stopped successfully"
        fi

    - name: Cleanup
      if: always()
      run: |
        rm -f server server.pid server.log
        pkill -f "./server" || true

  test-powershell-scripts:
    name: Test PowerShell Scripts
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5

    - name: Set up PostgreSQL
      uses: ikalnytskyi/action-setup-postgres@v8
      with:
        username: testuser
        password: testpassword
        database: testdb
        port: 5432
      id: postgres

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25'

    - name: Download dependencies
      run: go mod download

    - name: Test build script
      shell: pwsh
      run: |
        .\scripts\build.ps1
        Test-Path .\server.exe
        if (-not (Test-Path .\server.exe)) {
          throw "Server binary not created"
        }

    - name: Test test script
      shell: pwsh
      run: .\scripts\test.ps1

    - name: Test run-background and stop scripts
      shell: pwsh
      run: |
        # Set environment variables for the server
        $env:DATABASE_URL = "host=localhost user=testuser password=testpassword dbname=testdb port=5432 sslmode=disable"
        $env:JWT_SECRET = "test-secret-key"
        $env:SERVER_PORT = "8081"
        
        # Start server in background
        .\scripts\run-background.ps1
        if ($LASTEXITCODE -ne 0) {
          Write-Host "‚ùå Server failed to start. Dumping server.log:" -ForegroundColor Red
          Get-Content server.log -ErrorAction SilentlyContinue
          Get-Content server-error.log -ErrorAction SilentlyContinue
          exit 1
        }
        
        # Wait for server to start
        Start-Sleep -Seconds 3
        
        # Dump server log for debugging
        Write-Host "üìã Server log contents:" -ForegroundColor Cyan
        Get-Content server.log -ErrorAction SilentlyContinue
        
        # Check if server is responding
        try {
          Invoke-WebRequest -Uri http://localhost:8081/health -UseBasicParsing
          Write-Host "‚úÖ Health check passed" -ForegroundColor Green
        } catch {
          Write-Host "‚ö†Ô∏è Health check failed, but server may be running" -ForegroundColor Yellow
        }
        
        # Stop server
        .\scripts\stop.ps1
        
        # Verify server stopped
        Start-Sleep -Seconds 2
        try {
          Invoke-WebRequest -Uri http://localhost:8081/health -UseBasicParsing
          Write-Host "‚ùå Server still running!" -ForegroundColor Red
          exit 1
        } catch {
          Write-Host "‚úÖ Server stopped successfully" -ForegroundColor Green
        }

    - name: Cleanup
      if: always()
      shell: pwsh
      run: |
        Remove-Item -Path server.exe, server.pid, server.log, server-error.log -ErrorAction SilentlyContinue
        Get-Process | Where-Object {$_.ProcessName -eq "server"} | Stop-Process -Force -ErrorAction SilentlyContinue
