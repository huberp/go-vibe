name: Scripts Smoke Test

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'scripts/**'
      - '.github/workflows/scripts-test.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'scripts/**'
      - '.github/workflows/scripts-test.yml'

jobs:
  test-bash-scripts:
    name: Test Bash Scripts
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13-alpine
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Download dependencies
      run: go mod download

    - name: Test build script
      run: |
        ./scripts/build.sh
        test -f server
        ./server --version || echo "Server binary created successfully"

    - name: Test test script
      run: ./scripts/test.sh

    - name: Test run-background and stop scripts
      run: |
        # Set environment variables for the server
        export DATABASE_URL="host=localhost user=testuser password=testpassword dbname=testdb port=5432 sslmode=disable"
        export JWT_SECRET="test-secret-key"
        export SERVER_PORT="8081"
        
        # Start server in background
        ./scripts/run-background.sh || {
          echo "❌ Server failed to start. Dumping server.log:"
          cat server.log 2>/dev/null || echo "No server.log found"
          exit 1
        }
        
        # Wait for server to start
        sleep 3
        
        # Dump server log for debugging
        echo "📋 Server log contents:"
        cat server.log 2>/dev/null || echo "No server.log found"
        
        # Check if server is responding
        curl -f http://localhost:8081/health || echo "Health check failed, but server may be running"
        
        # Stop server
        ./scripts/stop.sh
        
        # Verify server stopped
        sleep 2
        if curl -f http://localhost:8081/health 2>/dev/null; then
          echo "Server still running!"
          exit 1
        else
          echo "Server stopped successfully"
        fi

    - name: Cleanup
      if: always()
      run: |
        rm -f server server.pid server.log
        pkill -f "./server" || true

  test-powershell-scripts:
    name: Test PowerShell Scripts
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'

    - name: Start PostgreSQL in Docker
      shell: pwsh
      run: |
        docker run -d `
          --name postgres `
          -e POSTGRES_USER=testuser `
          -e POSTGRES_PASSWORD=testpassword `
          -e POSTGRES_DB=testdb `
          -p 5432:5432 `
          postgres:13
        
        # Wait for PostgreSQL to be ready
        Write-Host "Waiting for PostgreSQL to be ready..."
        $maxAttempts = 30
        $attempt = 0
        $ready = $false
        
        while (-not $ready -and $attempt -lt $maxAttempts) {
          $attempt++
          try {
            $result = docker exec postgres pg_isready -U testuser -d testdb
            if ($result -match "accepting connections") {
              $ready = $true
              Write-Host "PostgreSQL is ready!"
            }
          } catch {
            Write-Host "Attempt $attempt/$maxAttempts - PostgreSQL not ready yet..."
            Start-Sleep -Seconds 2
          }
        }
        
        if (-not $ready) {
          Write-Host "PostgreSQL failed to start in time"
          docker logs postgres
          exit 1
        }
        
        # Verify PostgreSQL is running
        docker ps

    - name: Download dependencies
      run: go mod download

    - name: Test build script
      shell: pwsh
      run: |
        .\scripts\build.ps1
        Test-Path .\server.exe
        if (-not (Test-Path .\server.exe)) {
          throw "Server binary not created"
        }

    - name: Test test script
      shell: pwsh
      run: .\scripts\test.ps1

    - name: Test run-background and stop scripts
      shell: pwsh
      run: |
        # Set environment variables for the server
        $env:DATABASE_URL = "host=localhost user=testuser password=testpassword dbname=testdb port=5432 sslmode=disable"
        $env:JWT_SECRET = "test-secret-key"
        $env:SERVER_PORT = "8081"
        
        # Start server in background
        try {
          .\scripts\run-background.ps1
        } catch {
          Write-Host "❌ Server failed to start. Dumping server.log:"
          if (Test-Path server.log) {
            Get-Content server.log
          } else {
            Write-Host "No server.log found"
          }
          if (Test-Path server-error.log) {
            Write-Host "server-error.log contents:"
            Get-Content server-error.log
          }
          throw
        }
        
        # Wait for server to start
        Start-Sleep -Seconds 3
        
        # Dump server log for debugging
        Write-Host "📋 Server log contents:"
        if (Test-Path server.log) {
          Get-Content server.log
        } else {
          Write-Host "No server.log found"
        }
        
        # Check if server is responding
        try {
          Invoke-WebRequest -Uri "http://localhost:8081/health" -UseBasicParsing
        } catch {
          Write-Host "Health check failed, but server may be running"
        }
        
        # Stop server
        .\scripts\stop.ps1
        
        # Verify server stopped
        Start-Sleep -Seconds 2
        try {
          Invoke-WebRequest -Uri "http://localhost:8081/health" -UseBasicParsing -TimeoutSec 2
          Write-Host "Server still running!"
          exit 1
        } catch {
          Write-Host "Server stopped successfully"
        }

    - name: Cleanup
      if: always()
      shell: pwsh
      run: |
        Remove-Item -Path server.exe, server.pid, server.log, server-error.log -ErrorAction SilentlyContinue
        Get-Process | Where-Object {$_.ProcessName -eq "server"} | Stop-Process -Force -ErrorAction SilentlyContinue
        docker stop postgres 2>$null
        docker rm postgres 2>$null
